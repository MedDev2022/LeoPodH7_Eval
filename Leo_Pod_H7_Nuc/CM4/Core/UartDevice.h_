/****************************************************************************
**  Name:    UartDevice Driver (inherits UART)                             **
**  Author:  MK Medical Device Solutions Ltd.                             **
**  Website: www.mkmeddev.com                                             **
****************************************************************************/

#ifndef UARTDEVICE_H__
#define UARTDEVICE_H__

#include <vector>
#include <functional>
#include "Src/uart.h_"

/**
 * @brief High-level UART communication device inheriting from UART.
 * Provides callback handling and higher-level interface.
 */
class UartDevice : public UART {
public:
    /**
     * @brief Construct a UART device with given port, baud rate, and config.
     */
    UartDevice(USART_TypeDef* portName, uint32_t dwBaudRate, SerialConfig config = SERIAL_8N1);

    virtual ~UartDevice() = default;

    /**
     * @brief Initialize UART with custom parity and stop bits.
     */
    bool Connect(USART_TypeDef* portName, int baudRate);
    bool Connect(USART_TypeDef* portName, int baudRate, uint32_t parity, uint32_t stopBits);
    bool Disconnect();

    /**
     * @brief Set a high-level handler to receive processed data.
     */
    void SetReceiveHandler(std::function<void(const std::vector<uint8_t>&)> handler);

    /**
     * @brief Process the full received packet â€” override if needed.
     */
    virtual void HandleReceivedData(const std::vector<uint8_t>& data) = 0;

    /**
     * @brief Receive a single byte from base class (interrupt-driven).
     */
    void onUartRxByte(uint8_t byte) override;

    /**
     * @brief Notified when TX completes from base class.
     */
    void onUartTxComplete() override;

    void onUartRxComplete() override;

    /**
     * @brief Send a buffer over UART (non-blocking, interrupt-driven).
     */
    void SendCommand(const uint8_t* command, size_t length);

    /**
     * @brief Print string with newline.
     */
    void println(const char* message);

    /**
     * @brief Start interrupt-driven RX.
     */
    bool StartReceive(void* rxBuffer, size_t length);

    /**
     * @brief Return associated USART hardware instance.
     */
    USART_TypeDef* GetPort();

//    void onTransmitComplete() override;  // <-- make it virtual and public

    void onReceiveComplete() override;  // <-- make it virtual and public

protected:
    /**
     * @brief Called internally when message is complete.
     */
    virtual void OnDataReceivedHandler(const std::vector<uint8_t>& data);

    /**
     * @brief Try to send next message if queued.
     */
    void TrySendNext();

protected:
    std::vector<uint8_t> rxBuffer;
    std::function<void(const std::vector<uint8_t>&)> OnDataReceived;
    bool HardwareConnected = false;
    USART_TypeDef* DefaultPortName = nullptr;
    uint32_t DefaultBaudRate = 9600;
    SerialConfig DefaultConfig = SERIAL_8N1;
};

#endif /* UARTDEVICE_H__ */
